<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TinderDAO — Private Match</title>
  <style>
    /* NEW unique aesthetic: warm-cyan + burnt-orange cards, roomy layout */
    :root {
      --bg: linear-gradient(180deg,#0f172a 0%, #071129 100%);
      --card: rgba(255,255,255,0.04);
      --accent: #06b6d4;   /* cyan */
      --accent2: #fb923c;  /* orange */
      --muted: #94a3b8;
      --radius: 18px;
    }
    *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{margin:0;min-height:100vh;background:var(--bg);color:#e6eef8;padding:36px}
    .wrap {
  max-width: 1200px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 420px 1fr;
  gap: 28px;
}
@media (min-width: 1400px) {
  .wrap {
    max-width: 1280px;
    grid-template-columns: 400px 1fr;
  }
}
header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .brand{display:flex;gap:14px;align-items:center}
    .logo{width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:800}
    h1{margin:0;font-size:20px}
    .card{background:var(--card);border-radius:var(--radius);padding:18px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    label{display:block;color:var(--muted);font-weight:700;font-size:13px;margin-top:12px}
    input, select{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef8;margin-top:6px}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:none;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#031126;font-weight:700;cursor:pointer}
    .small{font-size:13px;color:var(--muted)}
    .col{display:flex;flex-direction:column;gap:12px}
    .right{display:flex;flex-direction:column;gap:12px}
    pre{white-space:pre-wrap;background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;color:#c6e6f1}
    footer{grid-column:1/-1;color:var(--muted);text-align:center;margin-top:20px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">TD</div>
        <div>
          <h1>TinderDAO — Private Match</h1>
          <div class="small">Encrypted profiles & preferences → homomorphic matching → no data leaks</div>
        </div>
      </div>
      <div>
        <button id="btnConnect" class="btn">Connect Wallet</button>
      </div>
    </header>

    <section class="card col">
      <h3>1) Publish Encrypted Profile</h3>
      <label>Age</label>
      <input id="profileAge" type="number" min="18" max="120" value="28"/>
      <label>Gender (0=unknown,1=male,2=female,3=other)</label>
      <input id="profileGender" type="number" min="0" max="3" value="1"/>
      <label>Interests bitmask (0..65535) — e.g., 1=music,2=movies,4=sports...</label>
      <input id="profileInterests" type="number" min="0" max="65535" value="5"/>
      <label>Region (numeric code)</label>
      <input id="profileRegion" type="number" min="0" max="65535" value="101"/>
      <div style="display:flex;gap:10px;margin-top:12px">
        <button id="btnPublish" class="btn">Encrypt & Publish</button>
        <div id="pubStatus" class="small"></div>
      </div>
    </section>

    <aside class="card right">
      <h3>Actions & Output</h3>
      <div style="display:flex;flex-direction:column;gap:8px">
        <div>
          <label>Profile ID (for later)</label>
          <input id="profileId" type="number" min="1" value="1"/>
        </div>
        <div>
          <label>Preference ID</label>
          <input id="prefId" type="number" min="1" value="1"/>
        </div>
        <div style="display:flex;gap:8px;margin-top:6px">
          <button id="btnGetHandle" class="btn">Compute Match</button>
          <button id="btnMakePublic" class="btn" style="background:linear-gradient(90deg,#f97316,#fb7185);color:white">Make Public</button>
        </div>
      </div>
      <div style="margin-top:12px">
        <label>Latest Output</label>
        <pre id="log">—</pre>
      </div>
    </aside>

    <section class="card col">
      <h3>2) Submit Encrypted Preference</h3>
      <label>Min Age</label>
      <input id="prefMinAge" type="number" min="18" max="120" value="24"/>
      <label>Max Age</label>
      <input id="prefMaxAge" type="number" min="18" max="120" value="35"/>
      <label>Desired Gender (255 = any)</label>
      <input id="prefGender" type="number" min="0" max="255" value="255"/>
      <label>Interests Mask (bitmask)</label>
      <input id="prefInterests" type="number" min="0" max="65535" value="1"/>
      <label>Region (65535 = any)</label>
      <input id="prefRegion" type="number" min="0" max="65535" value="65535"/>
      <div style="display:flex;gap:10px;margin-top:12px">
        <button id="btnSubmitPref" class="btn">Encrypt & Submit Pref</button>
        <div id="prefStatus" class="small"></div>
      </div>
    </section>

    <section class="card col">
      <h3>3) Decrypt Result (Public)</h3>
      <div class="small">After computing match, select ProfileID & PrefID, click Make Public (owner or requester), then Public Decrypt.</div>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="btnPublicDecrypt" class="btn">Public Decrypt</button>
        <div id="decStatus" class="small"></div>
      </div>
      <div style="margin-top:12px">
        <label>Decrypted Result</label>
        <pre id="decryptOut">—</pre>
      </div>
    </section>

    <footer>Built with Zama FHEVM • Relayer SDK 0.2.0 • Ethers v6</footer>
  </div>

  <script type="module">
    import { BrowserProvider, Contract, getAddress } from "https://cdn.jsdelivr.net/npm/ethers@6.13.4/+esm";
    import { initSDK, createInstance, SepoliaConfig } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";

    // CONFIG: change CONTRACT_ADDRESS if you deployed to another address on FHEVM
    const CONFIG = {
      RELAYER_URL: "https://relayer.testnet.zama.cloud",
      CONTRACT_ADDRESS: "0xB2408CdC456a1B82BaB30a2b0B35f108E8bEa4d1" 
    };

    // ABI - ensure bytes32 for handles and correct signatures
    const ABI = [
      "function publishProfile(bytes32,bytes32,bytes32,bytes32,bytes) external returns (uint256)",
      "function submitPreference(bytes32,bytes32,bytes32,bytes32,bytes32,bytes) external returns (uint256)",
      "function computeMatchHandle(uint256,uint256) external returns (bytes32)",
      "function makeMatchPublic(uint256,uint256) external",
      // view helpers
      "function ownerOfProfile(uint256) external view returns (address)",
      "function ownerOfPref(uint256) external view returns (address)"
    ];

    const $ = s => document.querySelector(s);
    const log = (t) => { const l = $("#log"); l.textContent = (new Date().toLocaleTimeString()) + "  " + t + "\n" + l.textContent; };
    const toHex = u8 => '0x' + Array.from(u8, b => b.toString(16).padStart(2,'0')).join('');

    let provider, signer, address, contract, relayer;

    async function connect() {
      if (!window.ethereum) throw new Error("Install MetaMask / compatible wallet");
      provider = new BrowserProvider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = await provider.getSigner();
      address = await signer.getAddress();
      contract = new Contract(getAddress(CONFIG.CONTRACT_ADDRESS), ABI, signer);
      $("#btnConnect").textContent = address.slice(0,6) + "…" + address.slice(-4);

      if (!relayer) {
        await initSDK();
        relayer = await createInstance({
          ...SepoliaConfig,
          relayerUrl: CONFIG.RELAYER_URL,
          network: window.ethereum,
          debug: true
        });
        console.info("Relayer ready");
      }
    }

    $("#btnConnect").onclick = async () => {
      try { await connect(); log("Wallet connected: " + address); } catch(e){ alert(e.message || e); }
    };

    // Helper: create encrypted input and return handles array + proof hex
    async function makeEncryptedForContract(typesValues) {
      // typesValues: array of { addMethod: 'add8'|'add16', value: BigInt }
      const enc = relayer.createEncryptedInput(getAddress(CONFIG.CONTRACT_ADDRESS), getAddress(address));
      for (const tv of typesValues) {
        if (tv.addMethod === "add8") enc.add8(BigInt(tv.value));
        else if (tv.addMethod === "add16") enc.add16(BigInt(tv.value));
        else throw new Error("Unsupported addMethod");
      }
      const { handles, inputProof } = await enc.encrypt();
      // handles elements: may be string or object with .handle/.ciphertext
      const extracted = handles.map(h => (typeof h === "string" ? h : (h.handle || h.ciphertext || h)));
      const proof = typeof inputProof === "string" ? (inputProof.startsWith("0x") ? inputProof : "0x" + inputProof) : toHex(inputProof);
      return { handles: extracted, proof };
    }

    // Publish Profile
    $("#btnPublish").onclick = async () => {
      try {
        await connect();
        const age = parseInt($("#profileAge").value);
        const gender = parseInt($("#profileGender").value);
        const interests = parseInt($("#profileInterests").value);
        const region = parseInt($("#profileRegion").value);
        $("#pubStatus").textContent = "Encrypting…";

        const { handles, proof } = await makeEncryptedForContract([
          { addMethod: "add8", value: age },
          { addMethod: "add8", value: gender },
          { addMethod: "add16", value: interests },
          { addMethod: "add16", value: region }
        ]);

        log("Profile encrypted, handles: " + handles.map(h=>h.slice(0,10)).join(", "));
        $("#pubStatus").textContent = "Sending tx…";
        const tx = await contract.publishProfile(handles[0], handles[1], handles[2], handles[3], proof);
        log("publish tx: " + tx.hash);
        await tx.wait();
        $("#pubStatus").textContent = "Profile published ✅";
      } catch (e) {
        console.error(e);
        $("#pubStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // Submit Preference
    $("#btnSubmitPref").onclick = async () => {
      try {
        await connect();
        const minAge = parseInt($("#prefMinAge").value);
        const maxAge = parseInt($("#prefMaxAge").value);
        const gender = parseInt($("#prefGender").value); // 255 = any
        const interests = parseInt($("#prefInterests").value);
        const region = parseInt($("#prefRegion").value);
        $("#prefStatus").textContent = "Encrypting…";

        const { handles, proof } = await makeEncryptedForContract([
          { addMethod: "add8", value: minAge },
          { addMethod: "add8", value: maxAge },
          { addMethod: "add8", value: gender },
          { addMethod: "add16", value: interests },
          { addMethod: "add16", value: region }
        ]);

        log("Pref encrypted, handles: " + handles.map(h=>h.slice(0,10)).join(", "));
        $("#prefStatus").textContent = "Sending tx…";
        const tx = await contract.submitPreference(handles[0], handles[1], handles[2], handles[3], handles[4], proof);
        log("submitPref tx: " + tx.hash);
        await tx.wait();
        $("#prefStatus").textContent = "Preference submitted ✅";
      } catch (e) {
        console.error(e);
        $("#prefStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // Compute Match Handle (calls computeMatchHandle and shows handle from event in logs)
    $("#btnGetHandle").onclick = async () => {
      try {
        await connect();
        const pid = parseInt($("#profileId").value);
        const qid = parseInt($("#prefId").value);
        log(`Computing match for profile ${pid} & pref ${qid}…`);
        const tx = await contract.computeMatchHandle(pid, qid);
        log("computeMatchHandle tx: " + tx.hash);
        const rec = await tx.wait();
        // Attempt to extract MatchComputed event with handle
        let handleFound = null;
        for (const ev of rec.events || []) {
          try {
            // ABI decoded events may appear; fallback to parsing topics/data if needed
            if (ev.event === "MatchComputed" && ev.args) {
              handleFound = String(ev.args[2]);
              break;
            }
          } catch {}
        }
        if (!handleFound) {
          // try scanning logs raw
          const logs = rec.logs || [];
          log("No MatchComputed event in receipt logs (might still be computed). Check explorer.");
          $("#log").textContent = "Encrypted Plan Handle:\n(see tx events in explorer)\n\n" + $("#log").textContent;
        } else {
          $("#log").textContent = ("Encrypted Match Handle:\n" + handleFound + "\n\n") + $("#log").textContent;
          log("Match handle: " + handleFound);
        }
      } catch (e) {
        console.error(e);
        log("Error computing match: " + (e.message || e));
      }
    };

    // Make match public (call by owner or requester)
    $("#btnMakePublic").onclick = async () => {
      try {
        await connect();
        const pid = parseInt($("#profileId").value);
        const qid = parseInt($("#prefId").value);
        $("#decStatus").textContent = "Sending make public tx…";
        const tx = await contract.makeMatchPublic(pid, qid);
        log("makeMatchPublic tx: " + tx.hash);
        await tx.wait();
        $("#decStatus").textContent = "Match made public ✅";
      } catch (e) {
        console.error(e);
        $("#decStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // Public decrypt (uses latest handle shown in log area)
    $("#btnPublicDecrypt").onclick = async () => {
      try {
        await connect();
        const txt = $("#log").textContent;
        const line = txt.split("\n").find(l => l.includes("Encrypted Match Handle:") || l.startsWith("Encrypted Match Handle:"));
        // try to parse handle from the top of log if present
        const possible = txt.split("\n")[0].trim();
        // let's extract first 0x... substring
        const m = txt.match(/0x[a-fA-F0-9]{64}/);
        const handle = m ? m[0] : null;
        if (!handle) throw new Error("No handle found in logs. Compute match first and ensure event emitted.");
        $("#decStatus").textContent = "Calling publicDecrypt…";
        const result = await relayer.publicDecrypt([handle]);
        console.log("publicDecrypt raw:", result);
        const raw = result[handle] ?? result[Object.keys(result).find(k=>k.toLowerCase()===handle.toLowerCase())];
        const val = Number(raw);
        const out = (val === 1) ? "MATCH ✅" : (val === 0 ? "NO MATCH ❌" : ("Unknown ("+raw+")"));
        $("#decryptOut").textContent = `Handle: ${handle}\nDecrypted value: ${raw}\nResult: ${out}`;
        $("#decStatus").textContent = "Done";
      } catch (e) {
        console.error(e);
        $("#decStatus").textContent = "Error: " + (e.message || e);
      }
    };

  </script>
</body>
</html>
